#Peiqi Hu, 1002263935, peiqi.hu@mail.utoronto.ca
#Jeff

------------------------------------------------------------------------
sploit1: This is a buffer overflow vulnerability. To overwrite the memory from the beginning of the buffer to the rip, we inject a buffer with 141 bytes which starts with 91 NOPs, then the shellcode and lastly the guessed return address with a null terminator. The guessed return address is the beginning of the buffer's location.  

------------------------------------------------------------------------
sploit3: This is a buffer overflow, similar to sploit1, with buffer size 64 bytes. Using gdb(especially inside foo) to figure out rip and the targ location, and then calculate the buffer size needs to exploit the vulnerability is 69 bytes. Fill the attacker buffer first with 19 NOPS, then shellcode and the guessed return address with a null terminator.  

------------------------------------------------------------------------
sploit5: This is a format string vulnerability. By using gdb, we find that there are 40 bytes between the argument pointer and the first byte of the format string. In other words, when we calculate number of bytes needed, that value should minus not only shellcode size but also 32 bytes, in order to move the argument pointer to the beginning of the format string. We use env to pass null to fill the return addresses, and three junks between return addresses, followed by a buffer with shellcode and a series of %x and %hhn. So that we can write desired return addr value to the specified return address. 

------------------------------------------------------------------------
sploit6: This is a double free vulnerability. We create two fake tags, one right before the q, the other right after the p's real tag. By finding the difference between the memory location of p and q (which is 80 bytes), we create a buffer with 81 bytes (extra byte for null). Fill the buffer with first fake tag(its prev points to the p.tag.next, its next filled with x01), following with the shellcode, then fill with x01 again until the second fake tag. The second fake tag's prev points to the p, next points to the guessed return address which is rip. Lastly, fill the last byte of the buffer with null. 
